from ophyd import EpicsSignalRO
import os, subprocess, shutil, socket
import redis
import BMM.functions  #from BMM.functions import verbosebold_msg, error_msg
from BMM.user_ns.base import startup_dir
UNREAL=True
if not os.environ.get('AZURE_TESTING'):
    redis_host = 'xf06bm-ioc2'
else:
    redis_host = '127.0.0.1'


class NoRedis():
    def set(self, thing, otherthing):
        return None
    def get(self, thing):
        return None
    
###################################################################
# things that are configurable                                    #
###################################################################

if UNREAL:
    rkvs = NoRedis()
else:
    rkvs = redis.Redis(host=redis_host, port=6379, db=0)
NAS = '/mnt/nfs/nas1'
LUSTRE_ROOT = '/nsls2/data'
LUSTRE_ROOT_BMM = '/nsls2/data/bmm'
SECRETS = os.path.join(LUSTRE_ROOT_BMM, 'XAS', 'secrets')
SECRET_FILES = ('slack_secret', 'image_uploader_token')
REDISVAR="BMM:scan:type"
###################################################################

rkvs.set('BMM:scan:type', 'idle')

def rkvs_keys(printed=True):
    '''Convert rkvs.keys() into a list of normal strings

    With printed=True, write a table of keys and values to the screen

    With printed=False, return a list containing keys as normal strings
    '''
    keys = sorted(list(x.decode('UTF-8') for x in rkvs.keys()))
    if printed is True:
        for k in keys:
            if rkvs.type(k) == b'string':
                print(f'{k:25} {rkvs.get(k).decode("UTF-8")}')
            elif rkvs.type(k) == b'list':
                this = ' '.join(x.decode('UTF-8') for x in rkvs.lrange(k, 0, -1))
                print(f'{k:25} {this}')
            else:
                #print(f'{k:25} {rkvs.get(k)}')
                pass
        return()
    else:
        return(keys)
    
CHECK = '\u2714'
TAB   = '\t\t\t'
wa    = EpicsSignalRO('XF:06BM-CT{}Prmt:RemoteExp-Sel', name='write_access')

def initialize_workspace():
    '''Perform a series of checks to see if the workspace on this computer
    is set up as expected by the BMM data collection profile.  This
    includes checks that:
      * channel access is enabled
      * servers can be seen on the LAN
      * various directories exist
      * Lustre mounted
      * a redis server is available
      * certain git repositories are cloned onto this computer
      * authentication files for Slack are available.

    For most checks, a failure triggers a corrective action, if
    possible.  Some failures print a warning to screen, with no
    corrective action.

    This is, essentially, a deployment verification that is run every
    time bsui starts.

    '''
    print(BMM.functions.verbosebold_msg('Checking workspace on this computer ...'))
  
    check_workstation_access()
    check_lan()
    check_profile_branch()
    initialize_data_directories()
    #initialize_beamline_configuration()
    initialize_lustre()
    #initialize_nas()
    initialize_secrets()
    initialize_redis()
    #initialize_gdrive()
    #initialize_ssh()
    
def check_workstation_access():
    if wa.get() == 0:
        print(BMM.functions.error_msg(f'{TAB}*** Uh oh!  The beamline is not enabled for write access to PVs!'))
        print(f'{TAB}    A beamline staff person needs to do:')
        print(f'{TAB}       caput XF:06BM-CT{{}}Prmt:RemoteExp-Sel 1')
        print(f'{TAB}    then restart bsui')
        print(f'{TAB}    (Now issuing a command that will fail and return to the command line.)')
        ## the next line is intended to trigger an immediate error and return to the IPython command line
        wa.put(1)
    else:
        print(f'{TAB}Channel access enabled: {CHECK}')
        
def check_lan():
    freakout = 0
    for host in ('ioc2', 'disp1', 'xspress3'):
        response = os.system(f"ping -q -c 1 xf06bm-{host} > /dev/null")
        if response != 0:
            print(BMM.functions.error_msg(f'{TAB}*** Uh oh!  xf06bm-{host} is not responding to a ping!'))
            freakout = 1;

    if freakout == 1:
        print(f'{TAB}    You may need to reboot the missing server(s).')
        print(f'{TAB}    Consult the DSSI support team for help.')
        print(f'{TAB}    (Now issuing a command that will fail and return to the command line.)')
        ## the next line is intended to trigger an immediate error and return to the IPython command line
        wa.put(1)
    else:
        print(f'{TAB}Servers on LAN are accessible: {CHECK}')
        
        
def check_profile_branch():
    here = os.getcwd()
    os.chdir(os.path.dirname(startup_dir))
    try:
        branch = subprocess.check_output(['git', 'branch', '--show-current']).decode("utf-8")[:-1]
    except subprocess.CalledProcessError:
        branch = "not a git repository"
    print(f'{TAB}Using profile branch {branch}: {CHECK}')
    os.chdir(here)
    
def check_directory(dir, desc):
    if os.path.isdir(dir):
        print(f'{TAB}{desc.capitalize()} directory {dir}: {CHECK}')
        return True
    else:
        print(f'{TAB}Making {desc} directory {dir}')
        os.mkdir(dir)
        return False

    
def initialize_data_directories():
    '''Verify that a Data directory is available under the home of the
    user running bsui.  Then verify that several subdirectories exist.
    Create any missing directories.

    '''
    DATA=f'{os.environ["HOME"]}/Data'
    check_directory(DATA, 'data')
    for sub in ('bucket', 'Staff', 'Visitors'):
        folder = f'{DATA}/{sub}'
        check_directory(folder, 'data')


def initialize_lustre():
    '''Check if a the Lustre mount point for data directories is mounted.
    If not, complain on screen.

    '''
    if os.path.ismount(LUSTRE_ROOT_BMM):
        print(f'{TAB}Found Lustre mount point: {CHECK}')
    else:
        print(BMM.functions.error_msg(f'{TAB}*** Uh oh! Lustre is not mounted!'))
        print(f'{TAB}    Consult the DSSI support team for help.')
        print(f'{TAB}    (Now issuing a command that will fail and return to the command line.)')
        ## the next line is intended to trigger an immediate error and return to the IPython command line
        wa.put(1)



def initialize_secrets():
    '''Check that the Slack secret files are in their expected locations.
    If not, copy them from Lustre at /nsls2/data/bmm/XAS/secrets.

    '''
    STARTUP = os.path.join(startup_dir, 'BMM')
    for fname in SECRET_FILES:
        if os.path.isfile(os.path.join(STARTUP, fname)):
            print(f'{TAB}Found {fname} file: {CHECK}')
        else:
            try:
                shutil.copyfile(os.path.join(SECRETS, fname), os.path.join(STARTUP, fname))
                print(f'{TAB}Copied {fname} file')
            except Exception as e:
                print(e)
                print(BMM.functions.error_msg(f'{TAB}Failed to copy {os.path.join(SECRETS, fname)}!'))

                
def initialize_redis():
    '''Check to see if a successful response can be obtained from a redis
    server.  If not, complain on screen.

    '''
    if rkvs.get(REDISVAR) is not None:
        print(f'{TAB}Found Redis server: {CHECK}')
    else:
        print(BMM.functions.error_msg(f'{TAB}*** Uh oh! Did not find redis server'))
        print(f'{TAB}    A beamline staff person needs to log onto xf06bm-ioc2:')
        print(f'{TAB}       dzdo systemctl start redis')
        print(f'{TAB}    then restart bsui')
        print(f'{TAB}    (Now issuing a command that will fail and return to the command line.)')
        ## the next line is intended to trigger an immediate error and return to the IPython command line
        wa.put(1)


def initialize_beamline_configuration():
    '''Check that a git directory exists beneath the home of the user
    running bsui.  Create the git directory and clone the
    BMM-beamline-configuration repository if absent.  If present, pull
    from the upstream repository to be sure the modes JSON file is up
    to date.

    '''
    GIT=f'{os.environ["HOME"]}/git'
    check_directory(GIT, 'git')
    BLC = f'{GIT}/BMM-beamline-configuration'
    existed = check_directory(BLC, 'git')
    here = os.getcwd()
    if existed:
        os.chdir(BLC)
        subprocess.run(['git', 'pull']) 
    else:
        os.chdir(GIT)
        subprocess.run(['git', 'clone', '-q', 'https://github.com/NSLS-II-BMM/BMM-beamline-configuration']) 
    os.chdir(here)

def initialize_nas():
    '''Check if a the NAS1 mount point is mounted.  If not, complain on
    screen.

    '''
    if os.path.ismount(NAS):
        print(f'{TAB}Found NAS1 mount point: {CHECK}')
    else:
        print(BMM.functions.error_msg(f'{TAB}NAS1 is not mounted!'))

def initialize_ssh():
    '''Check to see if xf06bm-ws3 has an authorized ssh key from this
    computer.  If not, complain on screen.

    '''
    if 'xf06bm-ws3' in socket.gethostname():
        print(f'{TAB}This is xf06bm-ws3, no ssh key needed: {CHECK}')
        return
    s = subprocess.run(['ssh', '-q', '-oBatchMode=yes', 'xf06bm@xf06bm-ws1', 'true'])
    if s.returncode == 0:
        print(f'{TAB}Key exists for xf06bm@xf06bm-ws3: {CHECK}')
    else:
        print(BMM.functions.error_msg(f'{TAB}Key does not exist for xf06bm@xf06bm-ws1'))
